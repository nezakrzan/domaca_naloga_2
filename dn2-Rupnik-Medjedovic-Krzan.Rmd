---
title: "2. domaca naloga"
author: "Tom Rupnik Medjedovic in Neza Krzan"
fontsize: 12pt
output:
  html_document:
    toc: yes
    toc_depth: 2
subtitle: Bayesova statistika
header-includes:
- \usepackage[slovene]{babel}
- \usepackage{float}
- \usepackage[T1]{fontenc}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
set.seed(123)
```

_Za primer iz 3. sklopa (uporabite zgornje podatke, model z $\sigma^2=0.1^2$ in zgornjo apriorno porazdelitev z $\mu_0=1.78$ in $\sigma_0^2 = 0.2^2$ -- ti parametri so fiksni) aproksimirajte aposteriorno porazdelitev s pomocjo algoritma Metropolis-Hastings, kjer sledite spodnjim korakom._

# Algoritem Metropolis-Hastings za ocenjevanje enega parametra
_1. Sami v R-u sprogramirajte algoritem Metropolis-Hastings za primer ocenjevanja enega parametra oz. za nas primer. Kljucno je, da ga sprogramirate sami, pri cemer splosnost kode in efektivnost implementacije nista pomembni. (Za ta preprost primer boste npr. 40000 iteracij dobili v zelo kratkem casu, ne glede na izbor parametrov v spodnjih tockah ali efektivnost implementacije.)_

```{r funkcije potrebne za algoritem, message=FALSE, warning=FALSE}
# Funkcija verjetja
verjetje <- function(theta, x, sigma){
  #cleni <- 1/(sqrt(2*pi)*sigma)* exp(-(x-theta)^2/(2*sigma^2))
  #return(prod(cleni))
  return(prod(dnorm(x, theta, sigma)))
}

# Apriorna porazdelitev
apriorna_porazdelitev <- function(theta, mu_0, sigma_0){
  return(dnorm(theta, mu_0, sigma_0))
}

#q funkcija
q <- function(theta_zvezdica, theta, sigma) { 
  return(dnorm(theta_zvezdica, theta, sigma))
}
```

```{r algoritem, message=FALSE, warning=FALSE}
metropolis_hastings <- function(n_itr, x, theta_zacetek, sigma, mu_0, sigma_0){
  # n_itr = ponovitve
  # x = podatki
  # theta_zacetek = theta s katero zacnemo in jo posodabljamo
  # sigma = sigma zacetnega modela
  # mu_0 in sigma_0 = parametra apriorne porazdelitve
  
  # Prazen vektor za shranjevanje
  theta <- numeric(n_itr)
  # Zacetna vrednost thete
  theta[1] <- theta_zacetek
    
  for(i in 2:n_itr){
    # Nova theta
    theta_zvezdica <- rnorm(1, theta[i - 1], sigma)
        
    # aposteriorna in verjetje s theta_zvezdica
    aposteriorna_zvezdica <- apriorna_porazdelitev(theta_zvezdica, mu_0, sigma_0)
    verjetje_zvezdica <- verjetje(theta_zvezdica, x, sigma)
    q_zvezdica <- q(theta[i - 1], theta_zvezdica, sigma)
        
    # aposteriorna in verjetje s theta_i
    aposteriorna_i <- apriorna_porazdelitev(theta[i - 1], mu_0, sigma_0)
    verjetje_i <- verjetje(theta[i - 1], x, sigma)
    q_i <- q(theta_zvezdica, theta[i - 1], sigma)
        
    # alpha
    alpha <- min(1, (aposteriorna_zvezdica * verjetje_zvezdica * q_zvezdica) / (aposteriorna_i * verjetje_i * q_i))
         
    # sprejmemo ali zavrnemo
    if(runif(1) < alpha){
        theta[i] <- theta_zvezdica # "accept" -> min(1, A)
        } 
    else{
      theta[i] <- theta[i - 1] # "reject"  -> theta_i
      }
    }

  return(theta)
}

```

# Preizkus algoritma
_2. Preizkusite ga na nasem primeru, kjer si sami izberite neko smiselno zacetno vrednost in varianco predlagalne porazdelitve. Rezultate predstavite na naslednji nacin:_\
   _- Narisite celotno dobljeno zaporedje $\theta^{(i)}$ (glede na iteracije $i$)._\
   _- Narisite le prvih 500 ali pa 5000 clenov._\
   _- Narisite celotno zaporedje, kjer uporabite ustrezen *burn-in*._\
   _- Za tako izbrano zaporedje graficno predstavite aposteriorno porazdelitev in jo graficno primerjajte s pravo aposteriorno porazdelitvijo._\
   _- Ocenite parameter in 95% interval zaupanja za parameter iz izbranega zaporedja ter primerjajte z ocenami iz prave aposterirone porazdelitve._\
   
Najprej algoritem stestirava na podatkih iz vaj, z naslednjimi vrednostmi\
$n_itr=40000,$\
$x \dots$ vzorec visin (metri) studentov moskega spola \
$\theta^0 = 1.5,$\
$\sigma^2=0.1^2,$\
$\mu_0 = 1.78,$\
$\sigma_0^2 = 0.2^2,$\
kjer $\theta^0$ predstavlja zacetni $\theta$, ki ga predlagamo v algoritmu in $\sigma$ predstavlja varianco predlagalne porazdelitve.
 
```{r testiranje algoritma, message=FALSE, warning=FALSE}
# Nastavitev parametrov
n_itr <- 40000 

x <- c(1.91, 1.94, 1.68, 1.75, 1.81, 1.83, 1.91, 1.95, 1.77, 1.98, 
       1.81, 1.75, 1.89, 1.89, 1.83, 1.89, 1.99, 1.65, 1.82, 1.65, 
       1.73, 1.73, 1.88, 1.81, 1.84, 1.83, 1.84, 1.72, 1.91, 1.63)

theta_zacetek <- 1.5

sigma <- 0.1
mu_0 <- 1.78
sigma_0 <- 0.2

# Test algoritma
theta <- metropolis_hastings(n_itr, x, theta_zacetek, sigma, mu_0, sigma_0)

```

```{r prava aposteriorna porazdelitev, message=FALSE, warning=FALSE}
# Prava aposteriorna porazdelitev
n <- length(x)

prec <- 1/sigma^2 
prec0 <- 1/sigma_0^2
prec.n <- prec0 + n*prec 
sigma.n <- sqrt(1/prec.n)

mu.n <- prec0/prec.n * mu_0 + n*prec/prec.n * mean(x)
```

## Graf celotnega zaporedja
Narisemo celotno dobljeno zaporedje $\theta^{(i)}$ (glede na iteracije $i$).
```{r graf, echo=TRUE, fig.align="center", fig.height=4, message=FALSE, warning=FALSE}
df <- data.frame(theta = theta)

library(ggplot2)
ggplot(df, aes(x=1:nrow(df), y=theta)) +
    geom_line() +
    labs(title="Celotno dobljeno zaporedje (glede na iteracije i)",
         x="Indeks",
         y=expression(theta)) +
    # zelena crta
    geom_hline(yintercept = c(qnorm(0.025, mu.n, sigma.n),qnorm(0.975, mu.n, sigma.n)),
               color = "green") +
    theme_bw() + 
    theme(panel.border = element_blank(),
              panel.grid.minor = element_blank(), 
              axis.line = element_line(colour = "black"),
          legend.position = "none") 
```
Na sliki sva za boljso predstavo oznacila 95% referencni interval prave aposterirone porazdelitve (zeleni crti).

## Prvih 500 in 5000 clenov zaporedja
Graf prvih 500 in 5000 clenov.
```{r prvi cleni, echo=FALSE, fig.align='center', fig.height=4, fig.width=10, message=FALSE, warning=FALSE}
library(knitr)
library(dplyr)

g1 <- ggplot(df %>% slice(1:500), aes(x=1:500, y=theta)) +
    geom_line() +
    labs(title="",
         x="Indeks",
         y=expression(theta)) +
    theme_bw() + 
    theme(panel.border = element_blank(),
              panel.grid.minor = element_blank(), 
              axis.line = element_line(colour = "black"),
          legend.position = "none") 

g2 <-ggplot(df %>% slice(1:5000), aes(x=1:5000, y=theta)) +
    geom_line() +
    labs(title="",
         x="Indeks",
         y=expression(theta)) +
    theme_bw() + 
    theme(panel.border = element_blank(),
              panel.grid.minor = element_blank(), 
              axis.line = element_line(colour = "black"),
          legend.position = "none") 

library(ggpubr)
ggarrange(g1, g2,
          labels = c("Prvih 500 clenov zaporedja", 
                     "Prvih 5000 clenov zaporedja"),
          font.label = list(size = 10),
          ncol = 2) 
```

## Celotno zaporedje z ustreznim _burn-in_
```{r metropolis_hastings_burn_in algoritem, message=FALSE, warning=FALSE}
metropolis_hastings_burn_in <- function(n_itr, x, theta_zacetek, sigma, mu_0, sigma_0, burn_in = FALSE){
  # n_itr = ponovitve
  # x = podatki
  # theta_zacetek = theta s katero zacnemo in jo posodabljamo
  # sigma = sigma zacetnega modela
  # mu_0 in sigma_0 = parametra apriorne porazdelitve
  
  # pridobimo theto
  metropolis_hastings(n_itr, x, theta_zacetek, sigma, mu_0, sigma_0)
  
  # v primeru burn in (odstranimo prvih 10% vzorca)
  n_burn_in = n_itr*0.1
  theta = theta[n_burn_in:length(theta)]
  
  return(theta)
}

# Test algoritma
theta <- metropolis_hastings_burn_in(n_itr, x, theta_zacetek, sigma, mu_0, sigma_0)
```

```{r graf burn-in, echo=FALSE, fig.align='center', fig.height=4, fig.width=10, message=FALSE, warning=FALSE}
# Risanje
df_burnin <- data.frame(theta = theta)

ggplot(df_burnin, aes(x=1:length(theta), y=theta)) +
    geom_line() +
    labs(title="Dobljeno zaporednje (prvih 10% zaporednja kot burn-in)",
         x="Indeks",
         y=expression(theta)) +
    # zelena crta
    geom_hline(yintercept = c(qnorm(0.025, mu.n, sigma.n),qnorm(0.975, mu.n, sigma.n)),
               color = "green") +
    theme_bw() + 
    theme(panel.border = element_blank(),
              panel.grid.minor = element_blank(), 
              axis.line = element_line(colour = "black"),
          legend.position = "none")
  
```

Na sliki sva za boljso predstavo oznacila 95% referencni interval prave aposterirone porazdelitve (zeleni crti).

## Aposteriorna porazdelitev in primerjava s pravo aposteriorno porazdelitvijo
Za tako izbrano zaporedje sva graficno predstavila aposteriorno porazdelitev in jo graficno primerjajla s pravo aposteriorno porazdelitvijo.

```{r graf - aposteriorna porazdelitev in prava aposteriorna porazdelitev, eval=TRUE, echo=FALSE, fig.align="center", fig.height=4, message=FALSE, warning=FALSE, results="markup"}
#ggplot(df %>% slice(501:n()), aes(x=theta)) +
    #geom_histogram(fill = "grey", color = "black") +
    #labs(x=expression(theta),
         #y="Frekvenca",
         #title="Aposteriorna porazdelitev",
         #subtitle="pridobljena z Metropolis-Hastings algoritmom brez burn-in dela") +
    #theme_bw() + 
    #theme(panel.border = element_blank(),
              #panel.grid.minor = element_blank(), 
              #axis.line = element_line(colour = "black"),
          #legend.position = "none")

# Ne vem cist tocno al rabva aposteriorno samo predstavt graficno al lahko vse skup v enem grafu, zato je zgori graf zakomentiran

# Graf aposteriorne porazdelitve in prave aposteriorne porazdelitve
ggplot(df %>% slice(501:n()), aes(x=theta)) +
    geom_histogram(aes(x = theta, y = ..density..), fill = "grey", color = "black") + 
    geom_density(color = "red", aes(colour = "MCMC"), show_guide=FALSE) +
    stat_function(fun = dnorm, args = list(mean=mu.n, sd=sigma.n), aes(colour = "prava")) +
    labs(x=expression(theta),
         y="Gostota",
         title="Aposteriorni porazdelitvi",
         subtitle="pridobljena z MH algoritmom (brez burn-in) in prava aposteriorna porazdelitev") +
  theme(legend.position = "topright") + 
  scale_color_manual(name = "", 
                     values = c("prava" = "green", "MCMC" = "red"),
                     labels = c("prava", "MCMC")) +
  stat_density(aes(colour="MCMC"), geom="line", position="identity") +
  theme_bw() + 
  theme(panel.border = element_blank(),
        panel.grid.minor = element_blank(), 
        axis.line = element_line(colour = "black"))

```


## Ocena parametra in 95% interval zaupanja za parameter
Poglejmo si se oceno za parameter $\theta$ in pripadajoc interval zaupanja za nas algoritem. Zaradi simetrinosti porazdelitve lahko sva za oceno parametra $\theta$ izbrala povprecje.

```{r ocena parametra in IZ, message=FALSE, warning=FALSE}
mh_alg <- rbind(mean(df %>% slice(1001:n()) %>% unlist()), mu.n)

ocena_pap <- rbind(quantile(df %>% slice(1001:n()) %>% 
                         unlist(), probs=c(0.025, 0.975)), 
              c(qnorm(0.025, mean=mu.n, sd=sigma.n), qnorm(0.975, mean=mu.n, sd=sigma.n)))

primerjava <- cbind(mh_alg, ocena_pap)

colnames(primerjava) <- c("Povprecje", "2.5%", "97.5%")
rownames(primerjava) <- c("Metropolis-Hastings algoritem", "Ocena iz prave aposteriorne porazdelitve")

library(kableExtra)
kable(primerjava, digits=5, booktabs=T) %>% 
    kable_styling(latex_options=c("striped", "hold_position"), full_width=FALSE)

```

# Zacetna vrednost $\theta$
_3. Pozenite vas algoritem pri neki nesmiselni zacetni vrednosti. **Pozor:** ce boste $\alpha$ implementirali po formuli iz str. 2, potem algoritem pri zelo nesmiselnih zacetnih vrednostih ne bo deloval -- zato je potrebno implementirati na ravni logaritma (primerno prilagodite korake algoritma).  Rezultate predstavite:_\
   _- Za visje tocke domace naloge: Opisite, zakaj konkretno so se pojavile tezave, ce ste uporabili zelo nesmiselno zacetno vrednost in osnovno verzijo algoritma (brez logaritmiranja). Algoritem ustrezno implementirajte tako, da bo deloval tudi pri zelo nesmiselnih zacetnih vrednostih._\
   _- Ce zgornje ne uspete narediti, pustite algoritem v osnovni varianti in izberite nekoliko manj nesmiselno zacetno vrednost._\
   _- Narisite celotno dobljeno zaporedje $\theta^{(i)}$ (glede na iteracije $i$)._\
   _- Narisite le prvih 500 ali pa 5000 clenov._\
   _- Narisite celotno zaporedje, kjer uporabite ustrezen *burn-in*._
   
Glede na to, da nas zanima visina studentov moskega spola, sva si za nesmiselno zacetno vrednost izbrala $\theta_{\text{zacetek}} = 0$, saj je nemogoce, da bi bila visina $0$. Vsi ostali parametri ostanejo enaki kot prej. Pri zagonu funkcije
```{r nesmiselne zacetne vrednosti, message=FALSE, warning=FALSE}
# Nastavim nesmiselno zacetno theto, ostali parametri ostanejo enako
theta_zacetek <- 0
# zakomentirano, da se koda ne izvede
#theta <- metropolis_hastings(n_itr, x, theta_zacetek, sigma, mu_0, sigma_0)

```

se pojavi napaka

  `Error in if (runif(1) < alpha) { : missing value where TRUE/FALSE needed`.
  
Vidiva, da je problem v if stavku pri primerjavi `runif(1)` in `alpha` ($\alpha$). V `runif(1)` ne more biti tezava, torej je problem le v izracunu $\alpha$. Nacin, kako sva izracunala $\alpha$ je naslednji

  `alpha <- min(1, (aposteriorna_zvezdica * verjetje_zvezdica * q_zvezdica) / (aposteriorna_i * verjetje_i * q_i))`. 

Problem lahko nastane, ko je kaksen izmed clenov `aposteriorna_i`, `verjetje_i` ali `q_i` enak $0$, saj potem pride do deljenja z $0$. Ce pogledamo kaj vrnejo te funkcije v primeru $\theta_{\text{zacetek}} = 0$
```{r}
verjetje(0, x, sigma)
apriorna_porazdelitev(0, mu_0, sigma_0)
q(theta_zvezdica, 0, sigma)
```

Vidimo, da je verjetje enako $0$, torej takoj delimo z $0$. Zato bomo celoten algoritem implementirali z logaritomom, da bo delovalo tudi pri zelo nesmiselnih zacetnih vrednostih.

Najprej ustrezno implementirava vse potrebne funkcije za algoritem.
```{r funkcije potrebne za algoritem, message=FALSE, warning=FALSE}
# Funkcija verjetja
verjetje_log <- function(theta, x, sigma){
    return(sum(dnorm(x, theta, sig_like, log=TRUE)))
}

# Apriorna porazdelitev
apriorna_porazdelitev_log <- function(theta, mu_0, sigma_0){
  return(dnorm(theta, mu_0, sigma_0, log=TRUE))
}

#q funkcija
q_log <- function(theta_zvezdica, theta, sigma){ 
  return(dnorm(theta_zvezdica, theta, sigma, log=TRUE))
}

```

```{r implementiran, message=FALSE, warning=FALSE}
metropolis_hastings_log <- function(n_itr, x, theta_zacetek, sigma, mu_0, sigma_0){
  # n_itr = ponovitve
  # x = podatki
  # theta_zacetek = theta s katero zacnemo in jo posodabljamo
  # sigma = sigma zacetnega modela
  # mu_0 in sigma_0 = parametra apriorne porazdelitve
  
  # Prazen vektor za shranjevanje
  theta <- numeric(n_itr)
  # Zacetna vrednost thete
  theta[1] <- theta_zacetek
    
  for(i in 2:n_itr){
    # Nova theta
    theta_zvezdica <- rnorm(1, theta[i - 1], sigma)
        
    # aposteriorna in verjetje s theta_zvezdica
    aposteriorna_zvezdica <- apriorna_porazdelitev_log(theta_zvezdica, mu_0, sigma_0)
    verjetje_zvezdica <- verjetje_log(theta_zvezdica, x, sigma)
    q_zvezdica <- q_log(theta[i - 1], theta_zvezdica, sigma)
        
    # aposteriorna in verjetje s theta_i
    aposteriorna_i <- apriorna_porazdelitev_log(theta[i - 1], mu_0, sigma_0)
    verjetje_i <- verjetje_log(theta[i - 1], x, sigma)
    q_i <- q_log(theta_zvezdica, theta[i - 1], sigma)
        
    # alpha
    alpha <- min(1, exp((aposteriorna_zvezdica + verjetje_zvezdica + q_zvezdica) - (aposteriorna_i + verjetje_i + q_i)))
         
    # sprejmemo ali zavrnemo
    if(runif(1) < alpha){
        theta[i] <- theta_zvezdica # "accept" -> min(1, A)
        } 
    else{
      theta[i] <- theta[i - 1] # "reject"  -> theta_i
      }
    }

  return(theta)
}

# Test algoritma
theta <- metropolis_hastings_log(n_itr, x, theta_zacetek, sigma, mu_0, sigma_0)
```

## Graf celotnega zaporedja
Ponovno algoritem stestirava na podatkih iz vaj, z naslednjimi vrednostmi\
$n_itr=40000,$\
$x \dots$ vzorec visin (metri) studentov moskega spola \
$\theta^0 = 1.5,$\
$\sigma^2=0.1^2,$\
$\mu_0 = 1.78,$\
$\sigma_0^2 = 0.2^2,$\.

Narisemo celotno dobljeno zaporedje $\theta^{(i)}$ (glede na iteracije $i$).
```{r graf, echo=TRUE, fig.align="center", fig.height=4, message=FALSE, warning=FALSE}
theta_zacetek <- 1.5
theta <- metropolis_hastings_log(n_itr, x, theta_zacetek, sigma, mu_0, sigma_0)

df_log <- data.frame(theta = theta)

ggplot(df_log, aes(x=1:nrow(df_log), y=theta)) +
    geom_line() +
    labs(title="Celotno dobljeno zaporedje (glede na iteracije i)",
         x="Indeks",
         y=expression(theta)) +
    # zelena crta
    geom_hline(yintercept = c(qnorm(0.025, mu.n, sigma.n),qnorm(0.975, mu.n, sigma.n)),
               color = "green") +
    theme_bw() + 
    theme(panel.border = element_blank(),
              panel.grid.minor = element_blank(), 
              axis.line = element_line(colour = "black"),
          legend.position = "none") 
```

Na sliki sva za boljso predstavo oznacila 95% referencni interval prave aposterirone porazdelitve (zeleni crti).

## Prvih 500 in 5000 clenov zaporedja
Graf prvih 500 in 5000 clenov.
```{r prvi cleni, echo=FALSE, fig.align='center', fig.height=4, fig.width=10, message=FALSE, warning=FALSE}
g1 <- ggplot(df_log %>% slice(1:500), aes(x=1:500, y=theta)) +
    geom_line() +
    labs(title="",
         x="Indeks",
         y=expression(theta)) +
    theme_bw() + 
    theme(panel.border = element_blank(),
              panel.grid.minor = element_blank(), 
              axis.line = element_line(colour = "black"),
          legend.position = "none") 

g2 <-ggplot(df_log %>% slice(1:5000), aes(x=1:5000, y=theta)) +
    geom_line() +
    labs(title="",
         x="Indeks",
         y=expression(theta)) +
    theme_bw() + 
    theme(panel.border = element_blank(),
              panel.grid.minor = element_blank(), 
              axis.line = element_line(colour = "black"),
          legend.position = "none") 

ggarrange(g1, g2,
          labels = c("Prvih 500 clenov zaporedja", 
                     "Prvih 5000 clenov zaporedja"),
          font.label = list(size = 10),
          ncol = 2) 
```

## Celotno zaporedje z ustreznim _burn-in_
```{r metropolis_hastings_burn_in algoritem, message=FALSE, warning=FALSE}
metropolis_hastings_log_burn_in <- function(n_itr, x, theta_zacetek, sigma, mu_0, sigma_0, burn_in = FALSE){
  # n_itr = ponovitve
  # x = podatki
  # theta_zacetek = theta s katero zacnemo in jo posodabljamo
  # sigma = sigma zacetnega modela
  # mu_0 in sigma_0 = parametra apriorne porazdelitve
  
  # pridobimo theto
  metropolis_hastings_log(n_itr, x, theta_zacetek, sigma, mu_0, sigma_0)
  
  # v primeru burn in (odstranimo prvih 10% vzorca)
  n_burn_in = n_itr*0.1
  theta = theta[n_burn_in:length(theta)]
  
  return(theta)
}

# Test algoritma
theta <- metropolis_hastings_log_burn_in(n_itr, x, theta_zacetek, sigma, mu_0, sigma_0)
```

```{r graf burn-in, echo=FALSE, fig.align='center', fig.height=4, fig.width=10, message=FALSE, warning=FALSE}
# Risanje
df_log_burnin <- data.frame(theta = theta)

ggplot(df_log_burnin, aes(x=1:length(theta), y=theta)) +
    geom_line() +
    labs(title="Dobljeno zaporednje (prvih 10% zaporednja kot burn-in)",
         x="Indeks",
         y=expression(theta)) +
    # zelena crta
    geom_hline(yintercept = c(qnorm(0.025, mu.n, sigma.n),qnorm(0.975, mu.n, sigma.n)),
               color = "green") +
    theme_bw() + 
    theme(panel.border = element_blank(),
              panel.grid.minor = element_blank(), 
              axis.line = element_line(colour = "black"),
          legend.position = "none")
  
```



